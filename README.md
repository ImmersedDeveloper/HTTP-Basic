
개발자는 평생 HTTP 기반 위에서 개발해야 합니다.
언젠가  한번은 HTTP에 대해 정리해야 할 필요가 있습니다.
HTTP의 전체 흐름을 이해해보도록 하겠습니다.

### Reference
[모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC#)

***

### 인터넷 네트워크

HTTP 프로토콜은 인터넷 망 위에서 동작합니다. 
배경적으로 먼저 인터넷의 통신이 어떤식으로 일어나는지 알아보겠습니다.

#### 인터넷에서 컴퓨터 둘은 어떻게 통신할까?
물리적으로 떨어져있는 두 대의 컴퓨터가 통신하기 위해선 중간에 "인터넷"이 필요합니다.
예를 들어 클라이언트 컴퓨터가 "Hello, world!"라는 메시지를 서버 컴퓨터에게 전달하려고 할 때, 인터넷의 동작방식은 단순하게 직접 바로 전달하는 것이 아니라
내부적으로 수 많은 [노드](https://en.wikipedia.org/wiki/Node_(networking)#:~:text=In%20telecommunications%20networks%2C%20a%20node,and%20protocol%20layer%20referred%20to.&text=A%20passive%20distribution%20point%20such,is%20consequently%20not%20a%20node.)들을 거쳐서 이동하는 복잡한 과정을 구성합니다.
인터넷 망을 통해 수 많은 노드들을 거쳐야 하기 때문에 내부적으로 상당히 복잡합니다.
이 복잡한 내부 과정들은 최소한의 "규칙"을 가지고 있습니다.
지금부터 하나씩 알아보도록 하겠습니다.

### IP(인터넷 프로토콜)
#### IP 주소 부여
컴퓨터가 통신하기 위해 복잡한 인터넷망을 사용하는 것은 각 컴퓨터에 IP 주소를 부여하는 것을 통해 가능해집니다.
#### IP(Internet Protocol)
인터넷 프로토콜의 역할
- __지정한 IP 주소(IP Adress)에 패킷(Packet)이라는 통신 단위로 데이터를 전달합니다.__


인터넷 프로토콜은 서로 다른 컴퓨터에게 메시지를 전달할 수 있도록 정해진 규칙입니다.
규칙의 내용은 다음과 같습니다.

> 클라이언트 패킷 전달
1. IP 패킷에 출발 IP 주소(클라이언트 주소)와 목적 IP 주소(서버 주소)를 저장합니다.
2. 전달할 요청 데이터를 IP 패킷으로 감쌉니다.
3. 전달 데이터가 포함되어 있는 IP 패킷을 인터넷 망에 전송합니다.
4. IP 프로토콜의 규약에 따라 출발지부터 목적지에 도착할 때까지 노드들이 패킷을 순차적으로 전달하여 목적 IP 주소에 패킷이 도착하게 됩니다.

패킷을 전달받은 컴퓨터로 마찬가지로 응답할 수 있습니다.
> 서버 패킷 전달
1. IP 패킷에 출발 IP 주소(서버 주소)와 목적 IP 주소(클라이언트 주소)를 저장합니다.
2. 전달할 응답 데이터를 IP 패킷으로 감쌉니다.
3. 전달 데이터가 포함되어 있는 IP 패킷을 인터넷 망에 전송합니다.
4. IP 프로토콜의 규약에 따라 출발지부터 목적지에 도착할 때까지 노드들이 패킷을 순차적으로 전달하여 목적 IP 주소에 패킷이 도착하게 됩니다.

- 참고 : 클라이언트와 서버가 각각 전송할 때 서로 다른 노드를 통해 전달될 수 있습니다.

하지만 IP 주소를 통한 위와 같은 방식에는 다음과 같은 한계가 있습니다.

#### IP 프로토콜의 한계
- __비연결성__
  - 패킷을 받을 대상이 없을 경우, 또는 서비스 불능 상태일 경우여도 패킷을 전송합니다.
- __비신뢰성__
  - 비연결성 때문에 패킷이 중간에 사라지거나 순서대로 도착하지 않을 수도 있어 신뢰할 수 없습니다.
- __프로그램 구분__ 
  - 같은 Ip를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 경우 구분하는 것에 한계가 있습니다.
  
  ![IP Protocol doesnt make sense](https://user-images.githubusercontent.com/79819812/153750613-12f2b917-437d-4242-b185-084c6a36f3d8.png)
  
  이러한 문제를 해결하기 위해 존재하는 TCP를 알아보겠습니다.
  
  ### TCP, UDP
  IP 프로토콜에서 발생된 문제들을 해결해 줍니다.
  설명하기에 앞서 인터넷 프로토콜 스택의 4계층을 살펴보겠습니다.
  
  아래 부터 순서대로 레이어가 쌓입니다.
  
  애플리케이션 계층
  전송 계층
  인터넷 계층
  네트워크 인터페이스 계층
  
  TCP는 IP를 보완하기 위해 IP 스택 위에 쌓인다고 이해하면 된다고 합니다.
  ![protocol layer](https://user-images.githubusercontent.com/79819812/153750814-a7071e7a-ed12-4650-8183-130b6f18c53d.png)

좀 더 자세히 살펴보면
우리가 사용하는 애플리케이션(Web browser, 게임, 채팅 프로그램..)
운영체제(Window, Linux, Mac..)
네트워크 인터페이스(LAN 드라이버, LAN 카드에 관련된 장비들..)
의 모습을 살펴볼 수 있습니다. 


  



  ![layer2](https://user-images.githubusercontent.com/79819812/153750817-0a7e19d5-f934-4fee-a0d4-ae4ce5fa9633.png)
  동작 순서는 다음과 같습니다.
1. 프로그램이 메시지 생성 (Hello, world!)
2. SOCKET 라이브러리를 통해 OS 계층에 메시지 전달
3. OS 계층에서 TCP 정보를 먼저 생성해서 메시지 데이터를 포함시킵니다.
  - IP 정보를 생성해서 데이터를 포함시킨 것과 같습니다.
4. IP 패킷을 생성해서 TCP 데이터를 포함시킨 후 네트워크 인터페이스를 통해 LAN 카드를 이용해
Ethernet frame을 포함시켜 인터넷 망으로 전송을 출발합니다.
  - [Ethernet frame](https://www.ionos.com/digitalguide/server/know-how/ethernet-frame/) : LAN 카드에 등록된 물리적인 주소, 데이터 패킷의 성공적인 전송을 담당
  
IP 패킷과 TCP 패킷이 정보를 생성해서 데이터를 포함시키는 과정은 다음과 같습니다.
  
  ![ip tcp packets](https://user-images.githubusercontent.com/79819812/153750819-b9f2b19f-ffc6-4475-9fe2-6937305d7ae2.png)
  
  TCP 데이터는 IP가 출발지와 목적지의 주소만 포함했던 것과 다르게
  __PORT, 전송 제어, 순서, 검증 정보__ 등을 포함시키는 것을 통해 IP 프로토콜의 여러 문제들이 해결됩니다.
 
 
 #### TCP 특징
 전송 제어 프로토콜(Transmission Control Protocol) : 출발지에서 목적지로 전송하는 것만을 담당했던 인터넷 프로토콜과 다르게 구체적으로 전송을 어떻게 할지 제어함으로써 문제를 해결하며 다음과 같은 특징을 가집니다.
 
 - __연결지향__ - TCP 3 way handshake (가상 연결)
   - 클라이언트와 서버의 연결 여부를 검증 후 메시지를 전송합니다. 따라서 비연결성이 해결됩니다.
 - __데이터 전달 보증__ : 메시지 전송 중 패킷 누락 여부를 알 수 있습니다.
 - 순서 보장
 
 이러한 특징들 때문에 __신뢰할 수 있는 프로토콜__이 되어 대부분 애플리케이션에서 TCP를 사용__한다고 합니다.
 
 
 #### TCP 3 way handshake
 연결지향이 가능하게 되는 원리는 다음과 같습니다.
 
 1. 클라이언트가 서버에게 SYN(synchronized)라는 메시지를 먼저 보냅니다.
 2. 서버가 SYN을 전달받으면 ACK(요청 확인)이라는 메시지를 포함하여 응답합니다.
 3. 서버에게 SYN+ACK를 전달받은 클라이언트는 ACK(응답 확인)를 다시 응답하여 연결 여부를 검증합니다. 이런 과정을 통해 클라이언트와 서버는 연결 여부를 확인하며 동시에 서로를 신뢰할 수 있게 됩니다.
 4. 연결이 되고나면 서버가 응답해야할 데이터를 클라이언트에게 전달합니다.
 연결 여부가 확인되지 않을 경우엔 데이터를 전송하지 않습니다.
 - 참고 : 요즘은 3에서 ACK와 함께 데이터를 포함시켜 한번에 전달하는 최적화가 되어있기도 합니다.
 
 가상 연결 : 사실 이 연결은 실제로 연결된 것이 아닌 개념적으로만 연결된 것입니다.
 물리적으로 선이 이어져있는게 아니라 논리적으로만 서로 연결되는 것을 확인하여 검증하는 것입니다. 즉, 전용 랜선이 보장 된 것은 아닙니다.
 
 ![tcp 3way handshake](https://user-images.githubusercontent.com/79819812/153751622-dd899d01-183d-45d6-b1b5-85af3e6cb7b9.png)
 
  
 #### 데이터 전달 보증, 순서 보장
 
 - 데이터 전달 보증 
  - TCP에서는 클라이언트가 서버에게 데이터를 전송하면 데이터를 잘 받았는지 서버가 응답해줍니다. 
  - 응답이 없을 경우 문제가 있는 것을 확인할 수 있습니다. 
  - 따라서, 정확한 데이터의 전달이 보증됩니다.
- 순서 보장
  - 클라이언트가 패킷을 전송한 순서와 서버에 도착한 순서가 서로 다를 경우, 기본적으로 서버는 잘못된 순서부터 재정렬후 재전송할 것을 클라이언트에게 요청합니다.
  - 따라서 데이터 전달의 순서가 보장됩니다.
 ![데이터 전달 보증, 순서 보장](https://user-images.githubusercontent.com/79819812/153751662-ada959a6-8823-43d4-bb2c-e50778011c02.png)
 
>3 way handshake, 데이터 전달 보증, 순서 보장은
TCP 패킷에 전송제어 정보, 순서 정보, 검증 정보 등을 포함하기 때문에 가능합니다.

#### UDP
사용자 데이터그램 프로토콜(User Datafram Protocol)

IP 계층 바로 위에 TCP와 함께 같은 공간에 존재합니다. UDP는 기능이 거의 없습니다.

- 하얀 도화지에 비유(기능이 거의 없음)
-  연결지향 - TCP 3 way handshake X
-  데이터 전달 보증 X
-  순서 보장 X
즉, IP와 거의 같습니다. 다만, PORT가 추가됩니다.
- PORT : 같은 IP 내 다른 프로그램들을 구분하기 위해 사용하는 체크섬(메시지 보증 데이터)

- UDP를 사용하는 이유
  - 3 way handshake를 사용하는 TCP보다 "단순하고 빠르다"라는 장점때문입니다.
  - 이미 체계가 구축되어 있는 TCP에 비해 원하는 것을 애플리케이션에서 최적화를 하고 싶어서 추가 작업을 필요로 할 때 사용합니다.


#### PORT

예를 들어 클라이언트가 두 개 이상의 서버에 연결해야 한다면 한 번에 여러 컴퓨터와 통신하게 됩니다. 이럴 경우 패킷이 혼동될 수 있습니다. 따라서 구분해야할 필요가 있습니다.

IP에서 출발지 IP와 목적지 IP를 포함했듯이,
TCP에서 출발지 PORT와 목적지 PORT를 IP 주소와 함께 포함합니다.

같은 IP 주소 내에서 애플리케이션의 프로세스를 구분하는 용도로 사용됩니다.
따라서 하나의 IP 주소를 가진 클라이언트에서 여러 요청을 받아도 서버는 각각 정확한 응답을 할 수 있게 됩니다.

![port](https://user-images.githubusercontent.com/79819812/153752594-2592a469-3259-488a-8f5d-72368fb36aea.png)

PORT의 특징은 다음과 같습니다.
- 0 ~ 65535까지 할당 가능합니다.
- 0 ~ 1023 : 잘 알려진 포트, 사용하지 않은 것이 좋다고 합니다.
  - FTP - 20, 21
  - TELNET - 23
  - HTTP - 80 (대표적인 포트)
  - HTTPS - 443
  
#### DNS

IP 프로토콜은 또 다른 문제를 가지로 있었습니다.
- IP는 주소가 길고 복잡해서 기억하기 어렵습니다. (예: 100.100.100.1)
- IP는 변경될 수 있습니다.
  - 시간이 지남에 따라 기존 IP가 신규 IP로 변경될 수 있습니다.
  - IP가 변경되면 동일한 서버에 접근할 수 없습니다.
  
이를 해결하기 위해 도메인 네임 시스템이 DNS(Domain Name System) 등장하게 되었습니다.

전화번호를 저장하고 관리하는 전화번호부 같은 서버를 제공해서 도메인명을 등록하고 IP 주소로 변환할 수 있는 원리입니다.

예를 들어 "google.com" 이라는 도메인을 구매해서 등록하면 도메인명을 IP 주소로 변환해서 관리하는 DNS 서버를 이용할 수 있게 됩니다.
DNS 서버에 저장되어 있는 도메인명을 통해 IP 주소를 모두 기억하지 않아도 되고, 변경되더라도 접근할 수 있게 되었습니다.

![dns](https://user-images.githubusercontent.com/79819812/153752967-2dcade92-2f33-45ca-b48a-20eaa5789116.png)

> 인터넷 네트워크 정리
- 인터넷 통신
  - 복잡한 인터넷 망에서 메시지를 통신하기 위해선 인터넷 프로토콜이 있어야 합니다.
- IP (Internet Protocol)
  - 인터넷 프로토콜은 한계가 있습니다. (비신뢰성, 비연결성, 프로그램 구분..)
- TCP, UDP
  - 이러한 IP의 문제를 TCP가 해결해줍니다.
  - IP의 문제를 해결해주는 TCP의 특징(3 way handshake, 데이터 전달 보증, 순서 보장)은
TCP 패킷에 전송제어 정보, 순서 정보, 검증 정보 등을 포함하기 때문에 가능합니다.
  - UDP도 해결에 도움이 됩니다. 거의 IP와 비슷하며 포트가 추가되며 필요에 따라 애플리케이션에서 기능을 확장할 수 있습니다.
- PORT
  - 같은 IP 내에서 동작하는 애플리케이션을 구분하기 위해 사용됩니다.
- DNS
  - IP는 기억하기 어렵고, 변경될 수 있다는 문제를 가지고 있었습니다.
  - 도메인명을 IP 주소로 변환해서 관리하는 DNS 서버에 접근하는 방식인 도메인 네임 시스템을 이용해서 문제를 해결할 수 있었습니다.


### URI와 웹 브라우저 요청 흐름

#### URI(Uniform Resource Identifier)

- Uniform : 리소스 식별하는 통일된 방식입니다.
- Resource : 자원, URI로 식별할 수 있는 모든 것(제한 없음)입니다. html파일 뿐만 아니라 식별할 수 있는 모든 data 자원을 의미합니다.
- Identifier : 다른 항목과 구분하는데 필요한 정보입니다.

URI? URL? URN?
[URI표준 스펙](https://www.ietf.org/rfc/rfc3986.txt)
"URI는 로케이터(locatior), 이름(name) 또는 둘 다 추가로 분류될 수 있다."

- URI(Uniform Resource Identifier) : 리소스를 식별합니다.
- URL(Uniform Resource Locator) : 리소스에 위치를 부여합니다. 변할 수 있습니다.
- URN(Uniform Resource Name) : 리소스에 이름을 부여합니다. 변하지 않습니다.

![uri](https://user-images.githubusercontent.com/79819812/153756031-ad19712b-5c5f-4d1f-a807-bb78a4029187.png)

- 참고 : URN 이름 만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되어 있지 않아서
리소스 결과 맵핑이 어렵기 때문에 주로 URL을 많이 사용한다고 합니다.

#### URL 분석 예시

https://www.google.com/search?q=hello&hl=ko



#### URL 전체 문법
- scheme://[userinfo@]host[:port][/path][?query][#fragment]
-  https://www.google.com:443/search?q=hello&hl=ko

> - 프로토콜(https)
- 호스트명(www.google.com)
- 포트 번호(443)
- 패스(/search)
- 쿼리 파라미터(q=hello&hl=ko)

- scheme : 주로 프로토콜에 사용됩니다.
  - 프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙 (http, https, ftp..)
  - http는 80 포트 , https는 443 포트를 주로 사용하며 포트는 생략이 가능합니다.
  - https는 http에 강력한 보안이 추가된 것입니다.([HTTP Secure](https://www.cloudflare.com/ko-kr/learning/ssl/what-is-https/)).
- userinfo : URL에 사용자 정보를 포함해서 인증해야 할 때 사용합니다. (거의 안 쓰인다고 합니다.)
- host : "호스트명"이라고 하며, 도메인명 또는 IP 주소를 직접 사용 가능합니다.
- port : 접속 포트, 일반적으로 생략 가능하며 생략시 http는 80, https는 443을 사용합니다.
- path : 리소스가 있는 경로입니다. 보통 계층적 구조로 되어있습니다. (ex. /home/file.jpg)
- query : key - value 형태로 데이터가 들어갑니다.
  - ?로 시작, &로 추가 가능 ?keyA=valueA&keyB=valueB
  - 웹 서버에 제공하는 파라미터이고 문자의 형태이기 때문에 보통 query parameter, query string 등으로 불립니다.
- fragment : html 내부에서 이동할 수 있는 북마크 등에 사용됩니다.
  - 서버에 전송되는 정보가 아닙니다.
  

#### 웹 브라우저 요청 흐름

https://www.google.com/search?q=hello&hl=ko
메시지를 요청할 씨의 웹 브라우저의 흐름을 자세히 살펴보면 다음과 같습니다.
1. 클라이언트는 DNS 서버 조회를 통해 접근합니다.
2. 예시에선 443(https는 포트 생략)을 통해 IP와 포트 정보를 찾아냅니다.
![getDns](https://user-images.githubusercontent.com/79819812/153757477-ab687f18-38d3-4db0-84f2-d5eb58bfde48.png)
3. HTTP 메시지를 3.1~3.3의 과정을 거쳐 생성하여 전송합니다.
![createHttpMessage](https://user-images.githubusercontent.com/79819812/153757125-7009819e-39df-4e69-a65f-e11165a5116b.png)

4. 3.1~3.3을 통해 생성된 패킷의 요청을 서버에 전달합니다.
![requestPacket](https://images.velog.io/images/urtimeislimited/post/211eb0ac-f808-480e-a551-8087d1e354c1/image.png)
5. 요청 패킷이 도착하면 서버가 패킷을 버리고 내부 메시지(데이터)를 분석합니다.
6. 서버는 분석 결과에 적절하게 응답할 메시지를 생성합니다.
7. 클라이언트와 마찬가지로 응답 패킷을 포함하여 전달합니다.
8. 클라이언트에게 응답 패킷이 도착하면 html 데이터를 렌더링하여 사용자의 화면에 보여줍니다.
![responsePacket](https://user-images.githubusercontent.com/79819812/153757130-947403af-64d8-41de-8839-03b105b2174a.png)
